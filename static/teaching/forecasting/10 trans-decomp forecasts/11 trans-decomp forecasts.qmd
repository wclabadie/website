---
title: "Forecasting with transformations and decomposition"
author: "BUS 323 Forecasting and Risk Analysis"
format: 
  revealjs:
    incremental: true
    html-math-method: mathjax
editor: visual
---

## Forecasting with transformed data
* Tranform data to improve forecast stability $w_{t} = f(y_{t}$)
    + Forecast transformed variable $w_{t}$
    + *Back-transform* to obtain forecasts for $y_{t}$
    
## Prediction intervals with transformed data
* Prediction interval computed for $\widehat{w}_{t}$
    + End-points back-transformed
    + Prediction interval not necessarily symmetric

## Bias adjustments
* Back-transformed point forecast not necessarily mean
    + Typically median 
    + Problem?
    + Larger variance $\rightarrow$ more difference between median and mean

## Example: Box-Cox transformation
* The back-transformation for a Box-Cox transformation is given by:
<div style="font-size: 85%;">
$$
\widehat{y}_{T+h|T} = \left\{\begin{array}{lr}
exp(\widehat{w}_{T+h|T}) & \textrm{if} \lambda=0; \\
sin(\lambda \widehat{w}_{T+h|T} + 1)(\lambda \widehat{w}_{T+h|T} + 1)^{1/\lambda} & \textrm{otherwise}.
\end{array}\right\}
$$
</div>
* This returns the **median** of the prediction interval.

## Example: Box-Cox transformation
* The back-tranformed **mean** is given by:
<div style="font-size: 85%;">
$$
\widehat{y}_{T+h|T} = \left\{\begin{array}{lr}
exp(\widehat{w}_{T+h|T})[1 + \frac{\sigma_{h}^{2}}{2}] & \textrm{if} \lambda=0; \\
(\lambda \widehat{w}_{T+h|T} + 1)^{1/\lambda}[1 + \frac{\sigma_{h}^{2}(1-\lambda)}{2(\lambda \widehat{w}_{T+h|T} + 1)^{2}}] & \textrm{otherwise}
\end{array}\right\}
$$
where $\widehat{w}_{T+h|T}$ is the $h$-step forecast mean and $\sigma_{h}^{2}$ is the $h$-step forecast variance on the transformed scale.

## Bias adjustments
* **bias**: The difference between the back-transformed forecast and the mean forecast
* **bias-adjusted**: uses the mean forecast rather than the back-transformed forecast

## Bias adjustments: example
* Drift forecast of egg prices using a log transformation. 
```{r}
#| echo: false
#| output: true
#| classes: fragment
library(fpp3)
fc <- prices |>
  filter(!is.na(eggs)) |>
  model(RW(log(eggs) ~ drift())) |>
  forecast(h = 50) |>
  mutate(.median = median(eggs))
fc |>
  autoplot(prices |> filter(!is.na(eggs)), level = 80) +
  geom_line(aes(y = .median), data = fc, linetype = 2, col = "blue") +
  labs(title = "Annual egg prices",
       y = "$US (in cents adjusted for inflation) ")
```
* Solid line: mean; dashed line: median

## Bias adjustments: example
* Back-transformed means automatically calculated with ```fable```. 
    + Median accessible using ```median()``` on the distribution variable.
```{r}
#| echo: true
#| output: true
#| classes: fragment
prices |>
  filter(!is.na(eggs))
```

## Bias adjustments: example
```{r}
#| echo: true
#| output: true
#| classes: fragment
prices |>
  filter(!is.na(eggs)) |>
    model(RW(log(eggs) ~ drift())) 
```

## Bias adjustments: example
```{r}
#| echo: true
#| output: true
#| classes: fragment
prices |>
  filter(!is.na(eggs)) |>
    model(RW(log(eggs) ~ drift())) |>
      forecast(h = 50) 
```

## Bias adjustments: example
```{r}
#| echo: true
#| output: true
#| classes: fragment
prices |>
  filter(!is.na(eggs)) |>
    model(RW(log(eggs) ~ drift())) |>
      forecast(h = 50) |>
        mutate(.median = median(eggs))
```

## Recall: decomposed vaiables
* Additive: $y_{t} = \widehat{S}_{t} + \widehat{A}_{t}$
    + where $\widehat{A}_{t} = \widehat{T}_{t} + \widehat{R}_{t}$ is the seasonally adjusted component.
* Multiplicative: $y_{t} = \widehat{S}_{t}\widehat{A}_{t}$

## Forecasting with decomposed variables
* To forecast, forecast $\widehat{S}_{t}$ and $\widehat{A}_{t}$ separately.
    + $\widehat{S}_{t}$ typically assumed unchanging
        - Thus a seasonal naive method used for $\widehat{S}_{t}$
    + $\widehat{A}_{t}$ can be forecasted with any appropriate method.

## Example: US retail employment
* First, filter ```us_retail_employment``` to ```year>=1990``` and ```Title=="Retail Trade"```
```{r}
#| echo: true
#| output: true
#| classes: fragment
us_retail_employment <- us_employment |>
  filter(year(Month) >= 1990, Title == "Retail Trade")
```

## Example: US retail employment
* Next, use an STL decompositionL
```{r}
#| echo: true
#| output: true
#| classes: fragment
dcmp <- us_retail_employment |>
  model(STL(Employed ~ trend(window = 7), robust = TRUE))
```

## Example: US retail employment
* Let's look at the components:
```{r}
#| echo: true
#| output: true
#| classes: fragment
dcmp <- us_retail_employment |>
  model(STL(Employed ~ trend(window = 7), robust = TRUE)) |>
  components()
dcmp
```

## Example: US retail employment
* And remove the ```.model``` column:
```{r}
#| echo: true
#| output: true
#| classes: fragment
us_retail_employment <- us_employment |>
  filter(year(Month) >= 1990, Title == "Retail Trade")
dcmp <- us_retail_employment |>
  model(STL(Employed ~ trend(window = 7), robust = TRUE)) |>
  components() |>
  select(-.model)
```

## Example: US retail employment
* Next, make a naive forecast the seasonally adjusted component:
```{r}
#| echo: true
#| output: true
#| classes: fragment
dcmp |>
  model(NAIVE(season_adjust)) |>
  forecast()
```

## Example: US retail employment
* Finally, use ```autoplot()``` to plot the forecast with the seasonal component added back in:
```{r}
#| echo: true
#| output: false
#| classes: fragment
dcmp |>
  model(NAIVE(season_adjust)) |>
  forecast() |>
  autoplot(dcmp) +
  labs(y = "Number of people",
       title = "US retail employment")
```

## Example: US retail employment
```{r} 
#| echo: false
#| output: true
#| classes: fragment
dcmp |>
  model(NAIVE(season_adjust)) |>
  forecast() |>
  autoplot(dcmp) +
  labs(y = "Number of people",
       title = "US retail employment")
```

## ```decomposition_model()```
* The ```decomposition_model()``` function makes this a bit simpler. 
    + Seasonal naive forecasts are used for the seasonal component automatically.
    + Also reseasonalizes the forecasts for you for observed data:
```{r}
#| echo: true
#| output: true
#| classes: fragment
fit_dcmp <- us_retail_employment |>
  model(stlf = decomposition_model(
    STL(Employed ~ trend(window = 7), robust = TRUE),
    NAIVE(season_adjust)
  ))
```

## ```decomposition_model()``` forecasts
* ```autoplot()``` will plot the forecasts for the original data as well as future forecasts:
```{r}
#| echo: true
#| output: false
#| classes: fragment
fit_dcmp |>
  forecast() |>
  autoplot(us_retail_employment)+
  labs(y = "Number of people",
       title = "US retail employment")
```

## ```decomposition_model()``` plot
```{r}
#| echo: false
#| output: true
#| classes: fragment
fit_dcmp |>
  forecast() |>
  autoplot(us_retail_employment)+
  labs(y = "Number of people",
       title = "US retail employment")
```
